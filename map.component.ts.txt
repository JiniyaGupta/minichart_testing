import {
  Component,
  OnInit,
  Output,
  Input,
  EventEmitter,
  OnChanges,
  Injector,
  SimpleChanges,
  OnDestroy,
} from '@angular/core';
import { FormioCustomComponent } from '@formio/angular';
import { geoJSON, Map, LayerGroup } from 'leaflet';
import * as L from 'leaflet';
import { geoJsonLabelKey, GeoJsonType } from 'src/app/enums/geo-json-type';
import { DataSourceType } from 'src/app/enums/data-source-type.enum';
import { GestureHandling } from 'leaflet-gesture-handling';
import { TranslateService } from '@ngx-translate/core';
import { CustomChart } from 'src/app/models/CustomChart';
import { BsModalService } from 'ngx-bootstrap/modal';
import { ColorUtils } from './colour.utils';
import { interval, Subject } from 'rxjs';
import { FilterService } from 'src/app/services/filter.service';
import { MapPathService } from 'src/app/services/map-path.service';
import { Indicator } from 'src/app/models/Map.model';
import { ComponentService } from 'src/app/components/component.service';
import { debounce, shareReplay, takeUntil } from 'rxjs/operators';
import { cloneDeep, isObject } from 'lodash';
import { UtilsService } from 'src/app/services/utils.service';
import { FormService } from 'src/app/services/form.service';


import { Chart } from 'chart.js';
@Component({
  selector: 'app-map',
  templateUrl: './map.component.html',
  styleUrls: ['./map.component.scss'],
})
export class MapComponent
  extends CustomChart
  implements OnInit, FormioCustomComponent<any>, OnChanges, OnDestroy {
  http: any;
  @Input() value: any;
  @Input() key: string;
  @Input() disabled: any;
  @Input() title: string = '';
  @Input() indicators: Indicator[];
  @Input() url: string;
  @Input() mapHeight = 25;
  @Input() applyGradient = false;
  @Input() ZoomValue: any = [];
  @Output() valueChange = new EventEmitter<any>();
  @Input() suffix: string;
  @Input() formatValue: number;
  @Input() notes: any;
  totalData: any = [];
  tooltip: any;
  btnFilter: string;
  chennaiZoom = 10;
  districtZoom = 7;
  zoomNumber: number = 12;
  mapData;
  mapOptions = {
    attributionControl: false,
    center: [11, 78],
    minZoom: 0,
    maxZoom: 15,
    zoomControl: false,
    zoomSnap: 0.25,
    zoom: 6.8,
    gestureHandling: true,
    layers: [],
  };
  markersLayer = new L.LayerGroup();
  layerGroup: LayerGroup;
  iconUrl = 'assets/icons/marker.png';
  mapLayers = [];
  defaultEmptyColor = '#d3cdcd30';
  geoJson = {
    url: 'assets/geo-json/district.min.geojson',
    style: {
      fillColor: this.defaultEmptyColor,
      weight: 0.75,
      opacity: 1,
      color: '#707070',
      fillOpacity: 1,
    },
    defaultFeatureBg: this.defaultEmptyColor,
    fillOpacity: 0.1,
  };
  map: Map;
  @Input() GeoJsonType: GeoJsonType[] = [];
  @Input() dataSource: DataSourceType;
  @Input() summary: any[];
  @Input() customValues: string;
  @Input() showFilter: boolean;
  @Input() customGeoJSON;
  @Input() tooltipSummary;
  formComponents = [];
  selectedOption = GeoJsonType.DISTRICT;
  toggleZoom = false;
  filterDays = 0;
  daySeries = [5, 4, 3, 2];
  _formValue: any = {};
  @Input() showComponentFilter: boolean;
  @Input() componentFilterSummary: string;
  @Input() componentFilterDataPath: string;
  @Input() componentFilterParameter: any;
  @Input() componentFilterOptions = [];
  @Input() textField;
  @Input() mapMarker: any;
  @Input() lat: string;
  @Input() lon: string;
  @Input() suffixFromFilter: boolean;
  previousMap: GeoJsonType;
  selectedButton: string;
  protected filterServ: FilterService;
  protected mapPath: MapPathService;
  currentMapData: any;
  multipleGroupBySummary: any;
  multipleSummary: boolean;
  formComponentSubscriber: any;
  mapSummarySubscriber: any;
  formDataSubscription: any;
  previousValueLength: number;
  renderQueue$ = new Subject();
  renderSubscription: any;
  geoJsonRequests: any = {};
  ngUnSubscribe$ = new Subject();
  isZoom: boolean = false;
  titleSuffix: string;
  modalMapLayers: any = [];
  updatedDate: any;
  chartsSet: boolean;
  constructor(
    private formServ: FormService,
    private translateServ: TranslateService,
    injector: Injector,
    modalService: BsModalService,
    private compServ: ComponentService,
    private utils: UtilsService,
    private colorUtils: ColorUtils
  ) {
    super(injector, modalService);
    this.mapPath = injector.get(MapPathService);
    Map.addInitHook('addHandler', 'gestureHandling', GestureHandling);
  }

  ngOnInit(): void {
    this.formComponents = this.formService.getPageComponentsList()?.components;
    this.renderSubscription = this.renderQueue$
      .pipe(debounce((val) => interval(200)))
      .subscribe((val) => {
       this.renderMapByDataSource(val);
        this.chartTitleSuffix = this.setChartTitleSuffix(
          this.translateServ,
          this.suffixFromFilter,
          this.titleSuffix
        );
      });

    this.formComponentSubscriber = this.compServ.pageFormComponents$.subscribe(
      (data) => {
        const formComponents =
          typeof data === 'string' ? JSON.parse(data) : data;
        this.mapPath.processMapMultipleGroupBy(formComponents);
        this.mapSummarySubscriber = this.mapPath.mapSummary$.subscribe(
          (mapSummary) => {
            this.multipleGroupBySummary = mapSummary;
          }
        );
      }
    );
  }
  ngOnChanges(changes: SimpleChanges): void {
    this.map?.invalidateSize();
    this.onSummaryChange(changes);
    if (changes?.GeoJsonType?.currentValue) {
      this.selectedOption = this.GeoJsonType[0] ?? GeoJsonType.DISTRICT;
    }
    this.setMapColorForMultipleGroupBy(
      this.summary,
      this.multipleGroupBySummary
    );
    if (changes.filterQueryParameters) {
      this.onFilterConfigChange();
    }    
  }
  ngOnDestroy(): void {
    this.ngUnSubscribe$.next();
    this.ngUnSubscribe$.complete();
    this.formComponentSubscriber?.unsubscribe();
    this.mapSummarySubscriber?.unsubscribe();
    this.formDataSubscription?.unsubscribe();
    this.renderSubscription?.unsubscribe();
  }
  onSummaryChange(changes: SimpleChanges) {
    if (changes.summary && !this.formDataSubscription) {
      this.formDataSubscription = this.linkedFormData$(
        this.getSummaries()
      ).subscribe((formDataResponse) => {
        if (formDataResponse) {
          this._formValue = formDataResponse;
          this.formData = formDataResponse;
          this.filterSet$?.next(true);
          if (this.dataSource === 'summary') {
            this.queueMapRender(formDataResponse);
          } else {
            this.queueMapRender(this._formValue);
          }
        }

        if (
          this.showComponentFilter &&
          this.componentFilterSummary &&
          formDataResponse
        ) {
          this.fetchComponentFilterOptions(
            formDataResponse[this.componentFilterSummary]
          );
        }
      });
    }
    this.checkAlternateSource(changes);
  }
  checkAlternateSource(changes: SimpleChanges) {
    if (
      changes.dataSource &&
      changes.dataSource.currentValue === DataSourceType.URL
    ) {
      this.getData(null);
    }
  }
  getSummaries() {
    return [
      { summary: this.mapMarker },
      ...[
        ...(this.tooltipSummary ? this.tooltipSummary : []),
        ...this.summary,
      ].map((map) => ({
        summary: map.summary,
      })),
    ];
  }
  getUpdatedInfo(event) {
    this.updatedDate = event;
  }
  setMapColorForMultipleGroupBy(summary, multipleGroupBySummary) {
    summary?.forEach((mapSummary) => {
      if (multipleGroupBySummary.includes(mapSummary.summary)) {
        this.multipleSummary = true;
      }
    });
  }
  setGeoJson() {
    if (this.GeoJsonType.length) {
      this.geoJson.url =
        this.customGeoJSON && this.selectedOption === GeoJsonType.DISTRICT
          ? `assets/geo-json/district32.min.geojson`
          : `assets/geo-json/${this.selectedOption}.min.geojson`;
    }
  }
  renderMapByDataSource(response) {
    switch (this.dataSource) {
      case DataSourceType.CUSTOM:
        if (this.customValues) {
          this.mapData =
            typeof response === 'string'
              ? JSON.parse(this.customValues)
              : this.customValues;
        }
        this.reRenderMap();      
        break;
      default:
        this.getData(response);
    }
  }
  getData(response): void {
    switch (this.dataSource) {
      case DataSourceType.SUMMARY:
        let mapData: any;
        const data = this.summary.find(
          (map) => map.type === this.selectedOption
        );
        if (response?.[data?.summary]) {
          mapData =
            typeof response[data.summary] === 'object'
              ? response[data.summary]
              : JSON.parse(response[data.summary]);
        }
        this.checkDataChange(mapData, response);

        const checkFilter = this.indicators.find((filter) => filter.mapFilter);
        this.btnFilter = checkFilter ? this.filterLabelSuffix : undefined;

        break;
      case DataSourceType.URL:
        if (this.url) {
          this.http.get(this.url).subscribe(
            (res: any) => {
              this.dataLoading = false;
              this.mapData = res;
              this.reRenderMap();
            },
            (err) => console.error(err)
          );
        }
        break;
      default:
        break;
    }

    this.reRenderMap();
  }
  checkDataChange(mapData: any, response: any) {
    if (mapData != null) {
      if (this.applyGradient) {
        const mappedValues = mapData.map((o) => o.value);
        const min = Math.min(...mappedValues);
        const max = Math.max(...mappedValues);
        this.indicators[0].min = min;
        this.indicators[1].max = Number(
          this.utils.formatLegendValue(
            { formatWithCommas: false, value: max },
            0,
            this.decimalPlaces
          )
        );
      }
      if (
        JSON.stringify(mapData) !== JSON.stringify(this.currentMapData) ||
        this.previousMap !== this.selectedOption
      ) {
        this.currentMapData = mapData;
        this.previousMap = this.selectedOption;
        this.mapData = mapData && JSON.parse(JSON.stringify(mapData));
        this.reRenderMap();
        this.addTooltip(response);
      }
    } else {
      this.reRenderMap();
    }
  }
  redrawChart() {
    this.dataLoading = false;
    this.reRenderMap();
  }
  addTooltip(response: any) {
    this.mapData?.forEach((summary) => {
      let tooltipLabel: any = [];
      this.tooltipSummary?.forEach((tooltipSummary) => {
        let areaValues;
        try {
          areaValues =
            typeof response[tooltipSummary.summary] === 'string'
              ? JSON.parse(response[tooltipSummary.summary])
              : response[tooltipSummary.summary];
        } catch (e) {
          console.warn(e);
        }
        if (areaValues?.find) {
          const value = areaValues?.find(
            (area) =>
              area._id === summary._id ||
              (typeof area._id === 'object' &&
                Object.values(area._id)[0] === Object.values(summary._id)[0])
          )?.value;
          if (value) {
            tooltipLabel.push(
              `${this.translateServ.instant(
                tooltipSummary.tooltip
              )} : ${this.formatNumValue(value, this.decimalPlaces)}`
            );
          }
        }
      });
      summary['tooltip'] = tooltipLabel;
    });
  }

  queueMapRender(data) {
    if (data) this.renderQueue$.next(data);
  }

  reRenderMap(): void {
    const setSuffix = this.filterQueryParameters?.find((item) => {
      return item.setSuffix === true;
    });
    if (setSuffix) {
      this.formServ.suffix$.subscribe((suffix) => {
        this.titleSuffix = this.translateServ.instant(
          suffix || this.suffix || '-'
        );
      });
    } else {
      this.titleSuffix = this.suffix;
    }
    this.setGeoJson();
    if (!this.geoJsonRequests[this.geoJson.url])
      console.log(this.geoJson.url);
      
      this.geoJsonRequests[this.geoJson.url] = this.http
        .get(this.geoJson.url)
        .pipe(shareReplay(1), takeUntil(this.ngUnSubscribe$));
    this.geoJsonRequests[this.geoJson.url].subscribe(
      (geojson: any) => {
        this.mapLayers = [];
        this.modalMapLayers = [];
        const geoJsonOptions = {
          style: this.geoJson.style,
          onEachFeature: (feature, layer: any) => {
            const property = this.getLabelKey(feature);
            let tooltipLabel: number = this.getItemLabelAndToolTip(
              property,
              false
            );

            let tooltip = this.getItemLabelAndToolTip(property, true);
            tooltipLabel = isNaN(+tooltipLabel)
              ? null
              : +(+tooltipLabel).toFixed(this.decimalPlaces);
            tooltip = tooltipType(tooltip);

            const suffix = this.translateServ.instant(
              this.titleSuffix ? this.titleSuffix : '-'
            );

            layer.bindTooltip(
              `<div style="${tooltip?.length > 0 && 'width:15em; white-space:normal;'
              }"><strong>
              ${property && this.translateServ.instant(property)} ${tooltipLabel
                ? `(${this.utils.formatLegendValue(
                  { formatWithCommas: true, value: tooltipLabel },
                  this.formatValue,
                  this.decimalPlaces
                )}${suffix})`
                : ''
              }
              </strong>
            </div>
              <div style="display:flex; word-break: break-word; flex-direction: column; gap: .5rem; margin-top:.25rem">
              ${tooltip?.length > 0
                ? tooltip.reduce((a, t) => {
                  return `${a}<div>${t}</div>`;
                })
                : ''
              }
              </div>
            `,
              {
                sticky: true,
                // permanent: true, // uncomment to debug
              }
            );
            layer.on({
              click: (mapArea) => {
                this.mapOnClick(mapArea, property, layer, geojson);
              },
            });
            layer.setStyle({
              fillColor: this.fillColor(tooltipLabel, property),
            });
          },
        };
        const geoJsonLayer = geoJSON(geojson, geoJsonOptions);
        this.mapLayers.push(cloneDeep(geoJsonLayer));
        this.modalMapLayers.push(cloneDeep(geoJsonLayer));



function getContinentCoordinates() {
  return {
    'North America': [54.8667, -109.0483], 
    'South America': [-9.1898, -67.6081],
    'Africa':  [0.2326, 15.5527],        
    'Europe':   [50.6419, 9.5576],     
    'Asia':     [34.2277, 108.9746],    
    'Australia': [-25.2744, 133.7751]    
  };
}

if (!this.chartsSet) {
  import('../../../assets/js/leaflet.minichart').then(() => {
    const continentCoordinates = getContinentCoordinates();

    for (const continentName in continentCoordinates) {
      const coordinates = continentCoordinates[continentName];

      const myPieChart = (L as any).minichart(coordinates, {
        type: 'pie',
        data: [60, 40], 
        labels: ['Male', 'Female'],
          colors: ['#59f', '#f95'],
        legendOptions: {
          boxStrokeColor: '#0000FF',
          boxFillColor: '#ffffff',
          labelTextColor: '#00FF00'
        },
        height: 60,
        width: 60
      });

      this.mapLayers.push(myPieChart);
    }
    this.chartsSet = false;
  });
}


        //this.addChart();
        // if(!this.chartsSet){
        // import('../../../assets/js/leaflet.minichart').then(()=>{

        //   const myPieChart = (L as any).minichart([48.861415, 2.349326], {
        //     type: 'pie',
        //     data: [70, 30],
        //     labels: ['Male', 'Female'],
        //     colors: ['#59f', '#f95'],
        //     legendOptions: {
        //       boxStrokeColor: '#0000FF',
        //       boxFillColor: '#ffffff',
        //       labelTextColor: '#00FF00'
        //     },
        //     height: 60,
        //     width: 60
        //   });
        //   this.mapLayers.push(myPieChart);
        //   this.chartsSet = true;
        // });
        // }
        // this.layerGroup = new L.LayerGroup();
        // var myBarChart = miniChart([80.861415, 2.349326], {
        //   data: [Math.random(), Math.random(), Math.random()],
        //   width: 600,
        //   height: 600,
        //   labels: 'Hello World'
        // });
        // console.log(myBarChart);
        // myBarChart.addTo(this.map);
        // this.layerGroup.addLayer(myBarChart);
        // this.mapLayers.push(cloneDeep(this.layerGroup));
        // 
        this.bindMarker(this.formData);
        try {
          geojson && this.map?.fitBounds(geoJSON(geojson).getBounds());
        } catch (e) {
          console.warn(e);
        }
      },
      (err) => {
        console.warn('Cannot get dist.geojson', err);
      }
    );
  }

  fillColor(found, property) {
    return this.btnFilter
      ? this.filterColor(found)
      : this.getColor(property, found) || this.geoJson.defaultFeatureBg;
  }
  getItemLabelAndToolTip(property, isToolTip: boolean): any {
    let found = this.mapData?.find((item) => {
      if (this.formatChartLabel(item) === property) {
        return item;
      }
    });
    found = !isToolTip ? found?.value : found?.tooltip;
    return found;
  }

  getLabelKey(feature) {
    return feature.properties[geoJsonLabelKey[this.selectedOption]];
  }
  updateValue(payload: any) {
    this.value = payload;
    this.valueChange.emit(payload);
    this.formService.customEvents[this.key]?.next(payload);
  }
  onMapReady(map: Map): void {
    this.map = map;
  }

  getColor(_id: string, found): string {
    if (!this.applyGradient) return this.getSolidColor(_id, found);
    return this.getGradientColor(_id, found);
  }
  getGradientColor(_id: string, found): string {
    for (let i = 1; i < this.indicators.length; i++) {
      let previousIndicator = this.indicators[i - 1];
      let indicator = this.indicators[i];
      if (found <= indicator.max) {
        return this.colorUtils.getMixedColor(
          indicator,
          previousIndicator,
          found
        );
      }
    }
    return this.geoJson.defaultFeatureBg;
  }
  getSolidColor(_id: string, found): string {
    for (const indicator of this.indicators) {
      if (found >= indicator.min && found <= indicator.max) {
        return this.colorUtils.getColorWithOpacity(
          indicator,
          found,
          this.applyGradient
        );
      }
    }
    return this.geoJson.defaultFeatureBg;
  }

  changeMap(option: GeoJsonType): void {
    this.selectedOption = option;

    this.getData(this._formValue);
  }

  fetchComponentFilterOptions(data): void {
    if (data) {
      data = typeof data === 'string' ? JSON.parse(data) : data;
      this.componentFilterOptions = data.map((option) => {
        return {
          name: this.formatChartLabel(option),
        };
      });
    }
  }

  changeComponentFilter(payload: string): void {
    this.formComponents.forEach((summaryComponent) => {
      if (summaryComponent.key === this.summary[0].summary) {
        const requestBody = this.formatFilterSummary(
          [this.componentFilterParameter?.key],
          [payload],
          summaryComponent
        );
        this.filterServ
          .filterSummary(requestBody)
          .subscribe((response: any) => {
           this.renderMapByDataSource(response);
          });
      }
    });
  }

  filterColor(found) {
    for (const indicator of this.indicators) {
      if (
        found &&
        this.btnFilter === indicator.mapFilter &&
        found >= indicator.min &&
        found <= indicator.max
      ) {
        return this.colorUtils.getColorWithOpacity(
          indicator,
          found,
          this.applyGradient
        );
      }
    }
    return this.geoJson.defaultFeatureBg;
  }

  bindMarker(mapData) {
    console.log('Binding...');

    if (mapData[this.mapMarker] !== undefined) {
      const markerLatLon = isObject(mapData[this.mapMarker])
        ? mapData[this.mapMarker]
        : JSON.parse(mapData[this.mapMarker]);
      if (markerLatLon !== null && markerLatLon.length) {
        this.layerGroup = new L.LayerGroup();
        for (const pointer of markerLatLon) {
          let icon;
          icon = new L.DivIcon({
            html: `<span <i class="fa fa-map-marker marker"></i></span>`,
          });

          const marker = L.marker(
            [Number(pointer[this.lat]), Number(pointer[this.lon])],
            {
              icon,
            }
          );
          this.layerGroup.addLayer(marker);
          let tooltipValue = Object.values(pointer._id)[0].toString();
          marker.bindTooltip(
            `<div style="${tooltipValue?.length > 0 && 'white-space:normal;'
            }"><strong>${tooltipValue && this.translateServ.instant(tooltipValue)
            }</strong>
            `
          );
        }
        this.mapLayers.push(cloneDeep(this.layerGroup));
        this.modalMapLayers.push(cloneDeep(this.layerGroup));
      }
    }

  }

  mapOnClick(mapArea, property, layer, geojson) {
    let mapValue = `${property}`;
    if (mapValue !== this.selectedButton) {
      this.selectedButton = mapValue;
      this.mapPath?.toggleStyles(mapArea.target._path);
      this.updateValue(mapValue);
    } else {
      this.selectedButton = '';
      this.updateValue(this.selectedButton);
      this.mapPath?.removeStyles(mapArea.target._path);
    }
    this.isZoom
      ? this.map.fitBounds(geoJSON(geojson).getBounds())
      : this.map.fitBounds(layer.getBounds());
    this.isZoom = !this.isZoom;
  }
}

function tooltipType(tooltip) {
  let tooltipType = typeof tooltip === 'object' ? tooltip : '';
  return tooltipType;
}







